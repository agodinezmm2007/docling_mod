# code_formula_model.py
# while this file is called "code_formula_model.py", this copy has been extensively modified to work with smoldocling
# file has been extensively modified to work with doclings DocTags, which according to the smoldocling paper,
# are what the SMolDocling model has been trained to identify. Change completed: 3/29/2025 18:00PM
import re
import logging
import numpy as np
from collections import Counter
from pathlib import Path
from typing import Iterable, List, Literal, Optional, Tuple, Union


from docling_core.types.doc.document import DEFAULT_EXPORT_LABELS

from PIL import Image, ImageOps
from pydantic import BaseModel
from docling_core.types.doc import (
    CodeItem,
    DoclingDocument,
    NodeItem,
    TextItem,
    BoundingBox,
    DocItem
)

from docling.datamodel.document import ConversionResult

from docling_core.types.doc.document import DocTagsDocument
from docling_core.types.doc.labels import DocItemLabel, CodeLanguageLabel

from docling.datamodel.base_models import ItemAndImageEnrichmentElement
from docling.datamodel.pipeline_options import AcceleratorOptions
from docling.models.base_model import BaseItemAndImageEnrichmentModel
from docling.utils.accelerator_utils import decide_device

_log = logging.getLogger(__name__)


class CodeFormulaModelOptions(BaseModel):
    """
    Configuration options for the SmolDoclingModel.
    Mirrors the CodeFormulaModelOptions, but is geared toward
    using the SmolDocling-256M-preview model behind the scenes.
    """
    kind: Literal["smoldocling"] = "smoldocling"
    do_code_enrichment: bool = True
    do_formula_enrichment: bool = True


class CodeFormulaModel(BaseItemAndImageEnrichmentModel):
    """
    Replacement for CodeFormulaModel that uses SmolDocling (Idefics3 architecture)
    for code/formula recognition from bounding-box images.
    """

    _model_repo_id = "ds4sd/SmolDocling-256M-preview"
    elements_batch_size = 5
    # images_scale = 1.66  # ~120 DPI
    images_scale = 2.6  # ~120 DPI
    expansion_factor = 0.18 # ORIGINALLY 0.2 : TEST 1 0.18
    # top_expansion_factor = 0.1 # was 0.06
    right_expansion_factor = 0.03
    left_expansion_factor = 0.04

    # expansion_factor = 0.21 #expansion factor of 0.21 kind of works with VLM pipeline

    def __init__(
        self,
        enabled: bool,
        artifacts_path: Optional[Path],
        options: CodeFormulaModelOptions,
        accelerator_options: AcceleratorOptions,
    ):
        """
        Initializes the SmolDoclingModel with the given configuration.

        Parameters
        ----------
        enabled : bool
            True if the model is enabled, False otherwise.
        artifacts_path : Path
            Path to the directory containing the model artifacts.
        options : SmolDoclingModelOptions
            Configuration options for the model.
        accelerator_options : AcceleratorOptions
            Device and thread config for acceleration.
        """
        super().__init__()
        self.enabled = enabled
        self.options = options

        if self.enabled:
            device = decide_device(accelerator_options.device)

            from docling_ibm_models.code_formula_model.code_formula_predictor import CodeFormulaPredictor

            # if artifacts_path is None:
            #     # If artifacts_path not given, we snapshot_download from HF
            #     artifacts_path = self.download_models()
            # else:
            #     # Just use the path the user provided:
            #     artifacts_path = artifacts_path

            # TEMPORARY CHANGE HERE:
            artifacts_path = self._model_repo_id  # "ds4sd/SmolDocling-256M-preview"
            
            self.code_formula_model = CodeFormulaPredictor(
                artifacts_path=str(artifacts_path),
                device=device,
                num_threads=accelerator_options.num_threads,
            )

    @staticmethod
    def download_models(
        local_dir: Optional[Path] = None,
        force: bool = False,
        progress: bool = False,
    ) -> Path:
        """
        Downloads the SmolDocling model from Hugging Face if not found locally.
        """
        from huggingface_hub import snapshot_download
        from huggingface_hub.utils import disable_progress_bars

        if not progress:
            disable_progress_bars()

        download_path = snapshot_download(
            repo_id="ds4sd/SmolDocling-256M-preview",
            force_download=force,
            local_dir=local_dir,
            revision="main",
        )
        return Path(download_path)

    def is_processable(self, doc: DoclingDocument, element: NodeItem) -> bool:
        """
        Returns True if the given doc element is a code snippet or a formula
        and if this model is enabled for those tasks.
        """
        if not self.enabled:
            return False

        # Check if it's a code snippet item
        if isinstance(element, CodeItem) and self.options.do_code_enrichment:
            return True

        # Check if it's a formula-labeled text item
        if (
            isinstance(element, TextItem)
            and element.label == DocItemLabel.FORMULA
            and self.options.do_formula_enrichment
        ):
            return True

        return False
    

    
    def prepare_element(
        self, conv_res: ConversionResult, element: NodeItem
    ) -> Optional[ItemAndImageEnrichmentElement]:
        if not self.is_processable(doc=conv_res.document, element=element):
            return None

        assert isinstance(element, DocItem)
        element_prov = element.prov[0]

        bbox = element_prov.bbox
        width = bbox.r - bbox.l
        height = bbox.t - bbox.b

        # Custom bounding box expansion:
        # expanded_bbox = BoundingBox(
        #     l=bbox.l - width * self.left_expansion_factor,
        #     t=bbox.t + height * self.top_expansion_factor,
        #     r=bbox.r + width * self.right_expansion_factor,
        #     b=bbox.b - height * self.expansion_factor,
        #     coord_origin=bbox.coord_origin,
        # )

#----------------------------------------------------------------------------------
        #testing defaults
        expanded_bbox = BoundingBox(
            l=bbox.l - width * self.left_expansion_factor,
            t=bbox.t + height * self.expansion_factor,
            r=bbox.r + width * self.right_expansion_factor,
            b=bbox.b - height * self.expansion_factor,
            coord_origin=bbox.coord_origin,
        )
#----------------------------------------------------------------------------------

        page_ix = element_prov.page_no - 1
        page = conv_res.pages[page_ix]

        # Fetch PDF identifier (using filename stem as identifier)
        pdf_identifier = conv_res.input.file.stem

        if element.label == DocItemLabel.FORMULA:
            cropped_image = page.get_masked_image(
                scale=self.images_scale, cropbox=expanded_bbox, pdf_identifier=pdf_identifier
            )


        else:
            cropped_image = page.get_image(
                scale=self.images_scale, cropbox=expanded_bbox
            )

        return ItemAndImageEnrichmentElement(item=element, image=cropped_image)



    def _extract_code_language(self, input_string: str) -> Tuple[str, Optional[str]]:
        """
        Pattern is <_Language_> content
        e.g., <_Python_> def foo():
        Returns remainder, language string
        """
        pattern = r"^<_([^_>]+)_>\s(.*)"
        match = re.match(pattern, input_string, flags=re.DOTALL)
        if match:
            language = str(match.group(1))
            remainder = str(match.group(2))
            return remainder, language
        else:
            return input_string, None

    def _get_code_language_enum(self, value: Optional[str]) -> CodeLanguageLabel:
        """
        Convert a string to CodeLanguageLabel enum or fallback to UNKNOWN.
        """
        if not isinstance(value, str):
            return CodeLanguageLabel.UNKNOWN

        try:
            return CodeLanguageLabel(value)
        except ValueError:
            return CodeLanguageLabel.UNKNOWN

    def _get_most_frequent_edge_color(self, pil_img: Image.Image) -> Union[int, Tuple[int, int, int]]:
        """
        Compute the most frequent color along the edges of a PIL image.
        Works for both grayscale and color images.
        """
        img_np = np.array(pil_img)
        if img_np.ndim == 2: # grayscale
            top = img_np[0, :]
            bottom = img_np[-1, :]
            left = img_np[:, 0]
            right = img_np[:, -1]
            edges = np.concatenate([top, bottom, left, right])
            freq = Counter(edges.tolist())
            most_common_value, _ = freq.most_common(1)[0]
            return int(most_common_value)
        else: # color
            top = img_np[0, :, :]
            bottom = img_np[-1, :, :]
            left = img_np[:, 0, :]
            right = img_np[:, -1, :]
            edges = np.concatenate([top, bottom, left, right], axis=0)
            edges_as_tuples = [tuple(pixel) for pixel in edges]
            freq = Counter(edges_as_tuples)
            most_common_value, _ = freq.most_common(1)[0]
            return most_common_value
#----------------------------------------------------------------------------
    def _pad_with_most_frequent_edge_color(
        self,
        img: Union[Image.Image, np.ndarray], 
        pad_top_ratio: float = 0.5,
        pad_bottom_ratio: float = 0.5,
        pad_left_ratio: float = 0.1,
        pad_right_ratio: float = 0.1
    ) -> Image.Image:
        """
        Pads an image with a border whose size is determined by a fixed ratio of the image dimensions.
        The border color is chosen as the most frequent edge color.
        
        Args:
            image: A PIL Image or a NumPy array representing the image.
            padding_ratio: A float representing the fraction of the image dimensions to use as padding.
            
        Returns:
            A padded PIL Image.
        """
        if isinstance(img, np.ndarray):
            pil_img = Image.fromarray(img)
        else:
            # Ensure the image is converted to RGB to standardize processing.
            pil_img = img.convert("RGB")

        # Compute dynamic padding amounts based on the image dimensions.
        width, height = pil_img.size
        pad_top = int(height * pad_top_ratio)
        pad_bottom = int(height * pad_bottom_ratio)
        pad_left = int(width * pad_left_ratio)
        pad_right = int(width * pad_right_ratio)

        most_freq_color = self._get_most_frequent_edge_color(pil_img)
        padded_img = ImageOps.expand(pil_img, border=(pad_left, pad_top, pad_right, pad_bottom), fill=most_freq_color)
        return padded_img

    # def _pad_with_most_frequent_edge_color(
    #     self, img: Union[Image.Image, np.ndarray], padding: Tuple[int, int, int, int]
    # ):
    #     """
    #     Pads an image (PIL or NumPy array) using the most frequent edge color.

    #     Parameters
    #     ----------
    #         img : Union[Image.Image, np.ndarray]
    #             The original image.
    #         padding : tuple
    #             Padding (left, top, right, bottom) in pixels.

    #     Returns
    #     -------
    #         Image.Image: A new PIL image with the specified padding.
    #     """
    #     if isinstance(img, np.ndarray):
    #         pil_img = Image.fromarray(img)
    #     else:
    #         pil_img = img

    #     most_freq_color = self._get_most_frequent_edge_color(pil_img)

    #     padded_img = ImageOps.expand(pil_img, border=padding, fill=most_freq_color)
    #     return padded_img

#----------------------------------------------------------------------------
    def __call__(
        self,
        doc: DoclingDocument,
        element_batch: Iterable[ItemAndImageEnrichmentElement],
    ) -> Iterable[NodeItem]:
        """
        Minimal call method that:
          1) Gathers formula/code items
          2) Pads snippet images
          3) Feeds them to the predictor
          4) Assigns the recognized text directly to item.text
             WITHOUT re-parsing or re-exporting snippet HTML.
        """

        if not self.enabled:
            for element in element_batch:
                yield element.item
            return

        images, labels, items = [], [], []

    # -------------------------------------------------------------
    # 1) Collect formula/code elements and pad snippet images
    # -------------------------------------------------------------

        for el in element_batch:
            try:
                # Only process elements that are clearly code or formulas.
                if not isinstance(el.item, TextItem):
                    # Not a text-based snippet; skip
                    yield el.item
                    continue

                if isinstance(el.item, CodeItem):
                    labels.append("code")
                elif isinstance(el.item, TextItem) and el.item.label == DocItemLabel.FORMULA:
                    labels.append("formula")
                else:
                    # Skip elements that are not of interest.
                    continue

    # -------------------------------------------------------------
    # 2) Expand bounding box with dynamic padding using a ratio
    # -------------------------------------------------------------

                try:
                    # e.g. 5% horizontal padding, 20% vertical padding
                    padded = self._pad_with_most_frequent_edge_color(
                        el.image, 
                        # padding_ratio_h=0.15, 
                        pad_top_ratio=0.13,      # Top padding (unchanged) 0.13
                        pad_bottom_ratio=0.13,   # Bottom padding (unchanged) 0.13
                        # pad_left_ratio=0.08,    # Smaller left padding
                        # pad_right_ratio=0.15    # Larger right padding to capture formula ends
                        pad_left_ratio=0.03,    # Smaller left padding 0.05
                        pad_right_ratio=0.03,    # ORIGINALLY 0.03
                        )
                except Exception as e:
                    _log.error("Error during padding for element %s: %s", el, e, exc_info=True)
                    continue  # Skip this element if padding fails

                images.append(padded)
                # images.append(
                # self._pad_with_most_frequent_edge_color(el.image, (20, 10, 20, 10))
                # )
                items.append(el.item)
            except Exception as e:
                _log.error("Error processing element %s: %s", el, e, exc_info=True)
                continue

    # -------------------------------------------------------------
    # 3) Run the predictor model (SmolDocling) on the snippet images
    # -------------------------------------------------------------
        try:
            snippet_ids = [f"{doc.name}_item_{i}" for i in range(len(images))]
            outputs = self.code_formula_model.predict(images, labels, snippet_ids=snippet_ids)
        except Exception as e:
            _log.error("Error during prediction: %s", e, exc_info=True)
            # As a fallback, use empty outputs for each image.
            outputs = [""] * len(images)

    # -------------------------------------------------------------
    # 4) Process model outputs => final text in doc-ling
    # -------------------------------------------------------------
        for idx, (item, doctag_output, lbl) in enumerate(zip(items, outputs, labels)):
            snippet_id = f"{doc.name}_item_{idx}"
            _log.debug("Snippet %s recognized text:\n%s", snippet_id, doctag_output, )

            # -------------------------------------------------------------
            # 4) Extract recognized code/formula from local_doc
            # -------------------------------------------------------------
            try:
                if lbl == "code":
                    item.text = doctag_output
                    item.code_language = CodeLanguageLabel.UNKNOWN  # You can refine if needed

                elif lbl == "formula":
                    item.text = doctag_output

                yield item

            except Exception as e:
                _log.error("Error processing output for item %s: %s; skipping item.", item, e, exc_info=True)
                continue
