# code_formula_model.py
# while this file is called "code_formula_model.py", this copy has been extensively modified to work with smoldocling
import re
import logging
import numpy as np
from collections import Counter
from pathlib import Path
from typing import Iterable, List, Literal, Optional, Tuple, Union

from PIL import Image, ImageOps
from pydantic import BaseModel
from docling_core.types.doc.document import DocTagsDocument
from docling_core.types.doc import (
    CodeItem,
    DoclingDocument,
    NodeItem,
    TextItem,
)
from docling_core.types.doc.labels import DocItemLabel, CodeLanguageLabel

from docling.datamodel.base_models import ItemAndImageEnrichmentElement
from docling.datamodel.pipeline_options import AcceleratorOptions
from docling.models.base_model import BaseItemAndImageEnrichmentModel
from docling.utils.accelerator_utils import decide_device

_log = logging.getLogger(__name__)


class CodeFormulaModelOptions(BaseModel):
    """
    Configuration options for the SmolDoclingModel.
    Mirrors the CodeFormulaModelOptions, but is geared toward
    using the SmolDocling-256M-preview model behind the scenes.
    """
    kind: Literal["smoldocling"] = "smoldocling"
    do_code_enrichment: bool = True
    do_formula_enrichment: bool = True


class CodeFormulaModel(BaseItemAndImageEnrichmentModel):
    """
    Replacement for CodeFormulaModel that uses SmolDocling (Idefics3 architecture)
    for code/formula recognition from bounding-box images.
    """

    _model_repo_id = "ds4sd/SmolDocling-256M-preview"
    elements_batch_size = 5
    images_scale = 1.66  # ~120 DPI
    expansion_factor = 0.18

    def __init__(
        self,
        enabled: bool,
        artifacts_path: Optional[Path],
        options: CodeFormulaModelOptions,
        accelerator_options: AcceleratorOptions,
    ):
        """
        Initializes the SmolDoclingModel with the given configuration.

        Parameters
        ----------
        enabled : bool
            True if the model is enabled, False otherwise.
        artifacts_path : Path
            Path to the directory containing the model artifacts.
        options : SmolDoclingModelOptions
            Configuration options for the model.
        accelerator_options : AcceleratorOptions
            Device and thread config for acceleration.
        """
        super().__init__()
        self.enabled = enabled
        self.options = options

        if self.enabled:
            device = decide_device(accelerator_options.device)

            from docling_ibm_models.code_formula_model.code_formula_predictor import CodeFormulaPredictor

            if artifacts_path is None:
                # If artifacts_path not given, we snapshot_download from HF
                artifacts_path = self.download_models()
            else:
                # Just use the path the user provided:
                artifacts_path = artifacts_path

            self.code_formula_model = CodeFormulaPredictor(
                artifacts_path=str(artifacts_path),
                device=device,
                num_threads=accelerator_options.num_threads,
            )

    @staticmethod
    def download_models(
        local_dir: Optional[Path] = None,
        force: bool = False,
        progress: bool = False,
    ) -> Path:
        """
        Downloads the SmolDocling model from Hugging Face if not found locally.
        """
        from huggingface_hub import snapshot_download
        from huggingface_hub.utils import disable_progress_bars

        if not progress:
            disable_progress_bars()

        download_path = snapshot_download(
            repo_id="ds4sd/SmolDocling-256M-preview",
            force_download=force,
            local_dir=local_dir,
            revision="main",
        )
        return Path(download_path)

    def is_processable(self, doc: DoclingDocument, element: NodeItem) -> bool:
        """
        Returns True if the given doc element is a code snippet or a formula
        and if this model is enabled for those tasks.
        """
        if not self.enabled:
            return False

        # Check if it's a code snippet item
        if isinstance(element, CodeItem) and self.options.do_code_enrichment:
            return True

        # Check if it's a formula-labeled text item
        if (
            isinstance(element, TextItem)
            and element.label == DocItemLabel.FORMULA
            and self.options.do_formula_enrichment
        ):
            return True

        return False

    def _extract_code_language(self, input_string: str) -> Tuple[str, Optional[str]]:
        """
        Pattern is <_Language_> content
        e.g., <_Python_> def foo():
        Returns remainder, language string
        """
        pattern = r"^<_([^_>]+)_>\s(.*)"
        match = re.match(pattern, input_string, flags=re.DOTALL)
        if match:
            language = str(match.group(1))
            remainder = str(match.group(2))
            return remainder, language
        else:
            return input_string, None

    def _get_code_language_enum(self, value: Optional[str]) -> CodeLanguageLabel:
        """
        Convert a string to CodeLanguageLabel enum or fallback to UNKNOWN.
        """
        if not isinstance(value, str):
            return CodeLanguageLabel.UNKNOWN

        try:
            return CodeLanguageLabel(value)
        except ValueError:
            return CodeLanguageLabel.UNKNOWN

    def _get_most_frequent_edge_color(self, pil_img: Image.Image):
        """
        Compute the most frequent color along the edges of a PIL image.
        """
        img_np = np.array(pil_img)
        if img_np.ndim == 2:
            # grayscale
            top = img_np[0, :]
            bottom = img_np[-1, :]
            left = img_np[:, 0]
            right = img_np[:, -1]
            edges = np.concatenate([top, bottom, left, right])
            freq = Counter(edges.tolist())
            most_common_value, _ = freq.most_common(1)[0]
            return int(most_common_value)
        else:
            # color
            top = img_np[0, :, :]
            bottom = img_np[-1, :, :]
            left = img_np[:, 0, :]
            right = img_np[:, -1, :]
            edges = np.concatenate([top, bottom, left, right], axis=0)
            edges_as_tuples = [tuple(pixel) for pixel in edges]
            freq = Counter(edges_as_tuples)
            most_common_value, _ = freq.most_common(1)[0]
            return most_common_value

    def _pad_with_most_frequent_edge_color(
        self, img: Union[Image.Image, np.ndarray], padding: Tuple[int, int, int, int]
    ):
        """
        Pads an image with the most frequent edge color.
        padding is (left, top, right, bottom).
        """
        if isinstance(img, np.ndarray):
            pil_img = Image.fromarray(img)
        else:
            pil_img = img

        most_freq_color = self._get_most_frequent_edge_color(pil_img)
        padded_img = ImageOps.expand(pil_img, border=padding, fill=most_freq_color)
        return padded_img

    def __call__(
        self,
        doc: DoclingDocument,
        element_batch: Iterable[ItemAndImageEnrichmentElement],
    ) -> Iterable[NodeItem]:
        """
        Processes the element batch. For each code snippet or formula image,
        calls the SmolDoclingPredictor to get text/latex output.
        """
        if not self.enabled:
            # If disabled, just return items unmodified
            for element in element_batch:
                yield element.item
            return

        # Gather images & labels for the entire batch
        images: List[Image.Image] = []
        labels: List[str] = []
        items: List[TextItem] = []  # store actual Doc Items (TextItem or CodeItem)

        for el in element_batch:
            if not isinstance(el.item, TextItem):
                yield el.item
                continue

            # The old code logic uses label == "code" or "formula"
            # So if it's a CodeItem, we'll pass label="code".
            # If CodeItem => label="code", if formula => label="formula"
            if isinstance(el.item, CodeItem):
                labels.append("code")
            elif el.item.label == DocItemLabel.FORMULA:
                labels.append("formula")
            else:
                # fallback
                labels.append("formula")

            # Expand bounding box with extra padding
            padded = self._pad_with_most_frequent_edge_color(el.image, (20, 10, 20, 10))
            images.append(padded)
            items.append(el.item)

        # Run the new predictor
        outputs = self.code_formula_model.predict(images, labels)

        # Assign the outputs back to items
        for item, output, lbl in zip(items, outputs, labels):
            if isinstance(item, CodeItem):
                # For code, we check if there's a <_Lang_> prefix
                remainder, code_lang = self._extract_code_language(output)
                item.code_language = self._get_code_language_enum(code_lang)
                item.text = remainder
            else:
                # For formula, we assume it returns LaTeX or text
                item.text = output

            yield item
