# code_formula_model.py
# while this file is called "code_formula_model.py", this copy has been extensively modified to work with smoldocling
# file has been extensively modified to work with doclings DocTags, which according to the smoldocling paper,
# are what the SMolDocling model has been trained to identify. Change completed: 3/29/2025 18:00PM
import re
import logging
import numpy as np
from collections import Counter
from pathlib import Path
from typing import Iterable, List, Literal, Optional, Tuple, Union

from PIL import Image, ImageOps
from pydantic import BaseModel
from docling_core.types.doc import (
    CodeItem,
    DoclingDocument,
    NodeItem,
    TextItem,
)
from docling_core.types.doc.document import DocTagsDocument
from docling_core.types.doc.labels import DocItemLabel, CodeLanguageLabel

from docling.datamodel.base_models import ItemAndImageEnrichmentElement
from docling.datamodel.pipeline_options import AcceleratorOptions
from docling.models.base_model import BaseItemAndImageEnrichmentModel
from docling.utils.accelerator_utils import decide_device

_log = logging.getLogger(__name__)


class CodeFormulaModelOptions(BaseModel):
    """
    Configuration options for the SmolDoclingModel.
    Mirrors the CodeFormulaModelOptions, but is geared toward
    using the SmolDocling-256M-preview model behind the scenes.
    """
    kind: Literal["smoldocling"] = "smoldocling"
    do_code_enrichment: bool = True
    do_formula_enrichment: bool = True


class CodeFormulaModel(BaseItemAndImageEnrichmentModel):
    """
    Replacement for CodeFormulaModel that uses SmolDocling (Idefics3 architecture)
    for code/formula recognition from bounding-box images.
    """

    _model_repo_id = "ds4sd/SmolDocling-256M-preview"
    elements_batch_size = 5
    images_scale = 1.66  # ~120 DPI
    expansion_factor = 0.18

    def __init__(
        self,
        enabled: bool,
        artifacts_path: Optional[Path],
        options: CodeFormulaModelOptions,
        accelerator_options: AcceleratorOptions,
    ):
        """
        Initializes the SmolDoclingModel with the given configuration.

        Parameters
        ----------
        enabled : bool
            True if the model is enabled, False otherwise.
        artifacts_path : Path
            Path to the directory containing the model artifacts.
        options : SmolDoclingModelOptions
            Configuration options for the model.
        accelerator_options : AcceleratorOptions
            Device and thread config for acceleration.
        """
        super().__init__()
        self.enabled = enabled
        self.options = options

        if self.enabled:
            device = decide_device(accelerator_options.device)

            from docling_ibm_models.code_formula_model.code_formula_predictor import CodeFormulaPredictor

            if artifacts_path is None:
                # If artifacts_path not given, we snapshot_download from HF
                artifacts_path = self.download_models()
            else:
                # Just use the path the user provided:
                artifacts_path = artifacts_path

            self.code_formula_model = CodeFormulaPredictor(
                artifacts_path=str(artifacts_path),
                device=device,
                num_threads=accelerator_options.num_threads,
            )

    @staticmethod
    def download_models(
        local_dir: Optional[Path] = None,
        force: bool = False,
        progress: bool = False,
    ) -> Path:
        """
        Downloads the SmolDocling model from Hugging Face if not found locally.
        """
        from huggingface_hub import snapshot_download
        from huggingface_hub.utils import disable_progress_bars

        if not progress:
            disable_progress_bars()

        download_path = snapshot_download(
            repo_id="ds4sd/SmolDocling-256M-preview",
            force_download=force,
            local_dir=local_dir,
            revision="main",
        )
        return Path(download_path)

    def is_processable(self, doc: DoclingDocument, element: NodeItem) -> bool:
        """
        Returns True if the given doc element is a code snippet or a formula
        and if this model is enabled for those tasks.
        """
        if not self.enabled:
            return False

        # Check if it's a code snippet item
        if isinstance(element, CodeItem) and self.options.do_code_enrichment:
            return True

        # Check if it's a formula-labeled text item
        if (
            isinstance(element, TextItem)
            and element.label == DocItemLabel.FORMULA
            and self.options.do_formula_enrichment
        ):
            return True

        return False

    def _extract_code_language(self, input_string: str) -> Tuple[str, Optional[str]]:
        """
        Pattern is <_Language_> content
        e.g., <_Python_> def foo():
        Returns remainder, language string
        """
        pattern = r"^<_([^_>]+)_>\s(.*)"
        match = re.match(pattern, input_string, flags=re.DOTALL)
        if match:
            language = str(match.group(1))
            remainder = str(match.group(2))
            return remainder, language
        else:
            return input_string, None

    def _get_code_language_enum(self, value: Optional[str]) -> CodeLanguageLabel:
        """
        Convert a string to CodeLanguageLabel enum or fallback to UNKNOWN.
        """
        if not isinstance(value, str):
            return CodeLanguageLabel.UNKNOWN

        try:
            return CodeLanguageLabel(value)
        except ValueError:
            return CodeLanguageLabel.UNKNOWN

    def _get_most_frequent_edge_color(self, pil_img: Image.Image) -> Union[int, Tuple[int, int, int]]:
        """
        Compute the most frequent color along the edges of a PIL image.
        Works for both grayscale and color images.
        """
        img_np = np.array(pil_img)
        if img_np.ndim == 2: # grayscale
            top = img_np[0, :]
            bottom = img_np[-1, :]
            left = img_np[:, 0]
            right = img_np[:, -1]
            edges = np.concatenate([top, bottom, left, right])
            freq = Counter(edges.tolist())
            most_common_value, _ = freq.most_common(1)[0]
            return int(most_common_value)
        else: # color
            top = img_np[0, :, :]
            bottom = img_np[-1, :, :]
            left = img_np[:, 0, :]
            right = img_np[:, -1, :]
            edges = np.concatenate([top, bottom, left, right], axis=0)
            edges_as_tuples = [tuple(pixel) for pixel in edges]
            freq = Counter(edges_as_tuples)
            most_common_value, _ = freq.most_common(1)[0]
            return most_common_value
        
    def _pad_with_most_frequent_edge_color(
        self, img: Union[Image.Image, np.ndarray], padding_ratio: float = 0.1
    ) -> Image.Image:
        """
        Pads an image with a border whose size is determined by a fixed ratio of the image dimensions.
        The border color is chosen as the most frequent edge color.
        
        Args:
            image: A PIL Image or a NumPy array representing the image.
            padding_ratio: A float representing the fraction of the image dimensions to use as padding.
            
        Returns:
            A padded PIL Image.
        """
        if isinstance(img, np.ndarray):
            pil_img = Image.fromarray(img)
        else:
            # Ensure the image is converted to RGB to standardize processing.
            pil_img = img.convert("RGB")

        # Compute dynamic padding amounts based on the image dimensions.
        width, height = pil_img.size
        pad_w = int(width * padding_ratio)
        pad_h = int(height * padding_ratio)

        most_freq_color = self._get_most_frequent_edge_color(pil_img)
        padded_img = ImageOps.expand(pil_img, border=(pad_w, pad_h, pad_w, pad_h), fill=most_freq_color)
        return padded_img

    def __call__(
        self,
        doc: DoclingDocument,
        element_batch: Iterable[ItemAndImageEnrichmentElement],
    ) -> Iterable[NodeItem]:
        if not self.enabled:
            for element in element_batch:
                yield element.item
            return

        images, labels, items = [], [], []

        # Process each element in the batch
        for el in element_batch:
            try:
                # Only process elements that are clearly code or formulas.
                if not isinstance(el.item, TextItem):
                    yield el.item
                    continue

                if isinstance(el.item, CodeItem):
                    labels.append("code")
                elif isinstance(el.item, TextItem) and el.item.label == DocItemLabel.FORMULA:
                    labels.append("formula")
                else:
                    # Skip elements that are not of interest.
                    continue

                # Expand bounding box with dynamic padding using a ratio (e.g., 0.1).
                try:
                    padded = self._pad_with_most_frequent_edge_color(el.image, 0.1)
                except Exception as e:
                    _log.error("Error during padding for element %s: %s", el, e, exc_info=True)
                    continue  # Skip this element if padding fails

                images.append(padded)
                items.append(el.item)
            except Exception as e:
                _log.error("Error processing element %s: %s", el, e, exc_info=True)
                continue

        # Run the predictor on the gathered images and labels.
        try:
            outputs = self.code_formula_model.predict(images, labels)
        except Exception as e:
            _log.error("Error during prediction: %s", e, exc_info=True)
            # As a fallback, use empty outputs for each image.
            outputs = [""] * len(images)

        # Process each prediction and update the corresponding item.
        for item, doctag_output, lbl, img in zip(items, outputs, labels, images):
            try:
                # If output contains expected DocTags markers, apply additional post-processing.
                if any(tag in doctag_output for tag in ["<doctag>", "<otsl>", "<formula>"]):
                    # Special handling for charts: replace <chart> with <otsl> and clean up location tags.
                    if "<chart>" in doctag_output:
                        doctag_output = doctag_output.replace("<chart>", "<otsl>").replace("</chart>", "</otsl>")
                        doctag_output = re.sub(r'(<loc_500>)(?!.*<loc_500>)<[^>]+>', r'\1', doctag_output)
                # Convert the (possibly cleaned-up) DocTags markup into a DocTagsDocument.
                try:
                    doctags_doc = DocTagsDocument.from_doctags_and_image_pairs([doctag_output], [img])
                except Exception as e:
                    _log.error("Error converting output to DocTagsDocument: %s. Using raw output.", e, exc_info=True)
                    doctags_doc = None

                # Load the DocTagsDocument into a temporary DoclingDocument if conversion succeeded.
                temp_doc = None
                if doctags_doc is not None:
                    try:
                        temp_doc = DoclingDocument(name="TempDoc")
                        temp_doc.load_from_doctags(doctags_doc)
                    except Exception as e:
                        _log.error("Error loading DocTagsDocument into DoclingDocument: %s. Using raw output.", e, exc_info=True)
                        temp_doc = None

                if lbl == "code":
                    if temp_doc is not None:
                        code_items = [el for el in temp_doc.texts if isinstance(el, CodeItem)]
                    else:
                        code_items = []
                    if code_items:
                        code_item = code_items[0]
                        item.text = code_item.text
                        item.code_language = code_item.code_language
                    else:
                        _log.warning("No code items extracted; using raw output.")
                        item.text = doctag_output
                        item.code_language = CodeLanguageLabel.UNKNOWN
                elif lbl == "formula":
                    if temp_doc is not None:
                        formula_items = [el for el in temp_doc.texts if el.label == DocItemLabel.FORMULA]
                    else:
                        formula_items = []
                    if formula_items:
                        item.text = formula_items[0].text
                    else:
                        _log.warning("No formula items extracted; using raw output.")
                        item.text = doctag_output

                yield item

            except Exception as e:
                _log.error("Error processing output for item %s: %s; skipping item.", item, e, exc_info=True)
                continue
